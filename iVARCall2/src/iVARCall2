#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-


#!/global/conda/envs/artwork/bin/python
import os, sys, re
import datetime
import time
from time import *
import argparse
import subprocess 
from os.path import exists
from shutil import copyfile
import copy


__doc__="""
Do the SNP calling from several FASTQ files

@requires: BWA
@requires: samtools
@requires: picard-tools
@requires: Trimmomatic
@requires: GATK
@requires: BAMmaker, iVCFmaker_SNP, iVCFmerge_SNP, VCFilter, VCFtoMATRIX and VCFtoFASTA in $PATH
@requires: Vcf.pm (vcftools)

Paired-end reads must be nammed as "prefix_R1.XXXX" and "prefix_R2.XXXX".
Example : E1_R1.fq and E1_R2.fq
"""

def get_parser():
	"""
	Parse arguments
	@return: arguments list
	@rtype: parser object
	"""

	parser = argparse.ArgumentParser(description='SNP calling workflow with independent VCF')

	parser.add_argument('-ref', action="store", dest='refFASTA', 
						type=str, required=True, help='reference genome in FASTA (REQUIRED)')

	parser.add_argument('-reads', action="store", dest='reads', 
						type=str, required=True, nargs='+', help='single-end reads FASTQ file or paired-end reads \
						FASTQ files  (REQUIRED). Paired-end reads must be nammed as "prefix_R1.XXXX" and "prefix_R2.XXXX", \
						example : E1_R1.fq and E1_R2.fq')

	parser.add_argument('-a', action="store", dest='adaptaters', 
						type=str, required=True, default=None, help='adaptaters FASTA file (REQUIRED)')

#	parser.add_argument('-TRIMJAR', action="store", dest='TRIMJAR', 
#						type=str, default='/opt/Trimmomatic/0.33/trimmomatic-0.33.jar', help='Trimmomatic jar path') #required=True

	parser.add_argument('-GATKJAR', action="store", dest='GATKJAR', type=str, help='GenomeAnalysisTK jar path') #required=True

#	parser.add_argument('-PICARDJAR', action="store", dest='PICARDJAR', 
#						type=str, default='/opt/picard-tools/1.133/picard.jar', help='picard-tools jar path') #required=True

	parser.add_argument('-o', action="store", dest='output', 
						type=str, default='output', help='output prefix (default:output)')

	parser.add_argument('-q', action="store", dest='minQuality', 
						type=int, default='30', help='min phred score per base for trimming (default:30)')

	parser.add_argument('-l', action="store", dest='minLen', 
						type=int, default='50', help='min read length for trimming (default:50)')
	
	parser.add_argument('-PL', action="store", dest='PL', 
						type=str, default='UNKNOWN', help='sequencing plateform for RG line (default:UNKNOWN)')

	parser.add_argument('-PU', action="store", dest='PU', 
						type=str, default='UNKNOWN', help='sequencer ID for RG line (default:UNKNOWN)')

	parser.add_argument('-LB', action="store", dest='LB', 
						type=str, default='UNKNOWN', help='sequencing library (default:UNKNOWN)')

	parser.add_argument('-T', action="store", dest='nbThreads', 
						type=int, default='1', help='maximum number of threads to use (default:1)')

	parser.add_argument('-m', action="store", dest='maxMemory', 
						type=int, default='4000', help='max memory to use in Mb (default:4000)')

	parser.add_argument('--removeDuplicates', dest='removeDuplicates', action='store_true', help='remove duplicated regions of the chromosome (default:False)', default=False)	

	parser.add_argument('--indelRealigner', dest='indelRealigner', action='store_true', help='local realignment around indels (default:False)', default=False)	

	parser.add_argument('--removeTmpFiles', dest='removeTmpFiles', action='store_true', help='remove temporary files (default:False)', default=False)

	parser.add_argument('--onlyVCF', dest='onlyVCF', action='store_true', help='stop process after making independent VCF files (default:False)', default=False)
	
	parser.add_argument('--slurm', dest='slurm', action='store_true', help='Jobs will be dispatched on a slurm queue instead of running locally. (default:False)', default=False)
	parser.add_argument('--slurmQueue', dest='slurmQueue', action='store', help='Slurm queue to run the jobs.',default="")


	return parser

def slurm_batch(name,cmd,Arguments,dependencies="",conda_env="artwork",threads=0,sync=0,mem=0 ):
	#print(Arguments.output)
	#print(os.getcwd())
	with open(Arguments.output+"/iVARCall2_"+name+"_"+Arguments.output+".sh","w", buffering=0) as file:
		file.write("#!/bin/bash\n")
		file.write("#SBATCH -J iVARCall2_"+name+"_"+Arguments.output+"\n")
		if mem!=0:
                        file.write("#SBATCH --mem="+str(mem)+"\n")
		if sync!=0:
                        file.write("#SBATCH -W\n")
		if threads==0:
			file.write("#SBATCH --cpus-per-task="+str(Arguments.nbThreads)+"\n")
		elif threads>=0:
			 file.write("#SBATCH --cpus-per-task="+str(threads)+"\n")
		else:
			file.write("#SBATCH --cpus-per-task=1\n")
		file.write("#SBATCH -o %x.%N.%j.out"+"\n")
		file.write("#SBATCH -e %x.%N.%j.err"+"\n")
		if Arguments.slurmQueue != "":
			file.write("#SBATCH -p "+str(Arguments.slurmQueue)+"\n")
		if conda_env:
			file.write("source /global/conda/bin/activate\nconda activate\nconda activate "+str(conda_env)+"\n\n")
		file.write("\n")
		file.write(str(cmd)+"\n")
		file.flush()
		file.close()
	slurm_cmd=['sbatch ', dependencies, " "+os.getcwd()+"/"+Arguments.output+"/iVARCall2_"+name+"_"+Arguments.output+".sh"]
	os.system("echo "+"".join(slurm_cmd) +" >> " + Arguments.output + "/" + Arguments.output + ".log" )
	print("".join(slurm_cmd))
	#return(re.findall(r'\d+',subprocess.check_output(['ls', '-l'])))
	return(re.findall(r'\d+',subprocess.check_output("".join(slurm_cmd), shell=True))[0])



#def slurm_sync(name,cmd,Arguments,dependencies="",conda_env="artwork",threads=0):
#	slurm_cmd="srun -J iVARCall2_"+name+"_"+Arguments.output+" -o %x.%N.%j.out -e %x.%N.%j.err "+str(dependencies)+" "+str(cmd)
#	if threads!=0:
#                   slurm_cmd=slurm_cmd+" "+"--cpus-per-task="+str(threads)
#	os.system("echo "+slurm_cmd +" >> " + Arguments.output + "/" + Arguments.output + ".log")
#	subprocess.check_output(slurm_cmd, shell=True)


def checkPE(readsList):
	"""
	checks all paired-end reads and reordering them
	@param readsList: list of reads given by the argument parser
	@type readsList: list
	@return: read list
	@rtype: list
	"""

	
	ordered_readList = []

	tmpList = []

	for reads in readsList :

		prefix = reads.split(".")[0]
		

		if('_R1.' in reads or '_1.' in reads or '_R2.' in reads or '_2.' in reads) :

			flag = False

			for element in tmpList :
				if(prefix[:len(prefix)-1] in element):
					if('_R1.' in reads or '_1.' in reads):
						ordered_readList.append(reads + " " + element)
					else:	
						ordered_readList.append(element + " " + reads)
					flag = True
					break	

			if not flag :
				tmpList.append(reads)

			else:
				tmpList.remove(element)		

		else :
			ordered_readList.append(reads)				
			
	if(len(tmpList)>0):
		print "ERROR : miss PE reads or named incorrectly!"
		sys.exit(1)			

	return ordered_readList		


def checkFiles(fileList):
	"""
	Check if all file of a list exist
	@param fileList: list file pathway
	@type fileList: list
	"""

	for element in fileList :
		if(exists(element)==False):
			print "ERROR : file " + element + " don't exist!"
			sys.exit(1)	


def commandLaunched(Arguments, logFile):
	"""
	Print VarCall command in log file
	@param Arguments: list of arguments
	@type Arguments: parser object
	@param logFile: log file
	@type logFile: string
	"""

	os.system("echo iVarCall2 >> " + logFile )
	os.system("echo " + "-ref " + Arguments.refFASTA + " >> " + logFile )
	os.system("echo " + "-reads " + " ".join(Arguments.reads) + " >> " + logFile )
	os.system("echo " + "-ref " + Arguments.refFASTA + " >> " + logFile )
	os.system("echo " + "-a " + Arguments.adaptaters + " >> " + logFile )
	os.system("echo " + "-o " + Arguments.output + " >> " + logFile )
	os.system("echo " + "-q " + str(Arguments.minQuality) + " >> " + logFile )
	os.system("echo " + "-l " + str(Arguments.minLen) + " >> " + logFile )
	os.system("echo " + "-T " + str(Arguments.nbThreads) + " >> " + logFile )
	os.system("echo " + "-m " + str(Arguments.maxMemory) + " >> " + logFile )

	if Arguments.removeDuplicates :
		os.system("echo --removeDuplicates >> " + logFile )

	if Arguments.indelRealigner :
		os.system("echo --indelRealigner >> " + logFile )
		
	if Arguments.removeTmpFiles :
		os.system("echo --removeTmpFiles >> " + logFile )	
	

#main function	
def main():	

	#execution time
	t1 = datetime.datetime.now()

	##################### gets arguments #####################
	parser=get_parser()
	
	#print parser.help if no arguments
	if len(sys.argv)==1:
		parser.print_help()
		sys.exit(1)
	
	Arguments=parser.parse_args()

	if not Arguments.GATKJAR:
                gatk_path=os.path.join(os.environ['CONDA_PREFIX'],"bin","GenomeAnalysisTK.jar")
        else:
                gatk_path=Arguments.GATKJAR



	fileList = copy.copy(Arguments.reads)
	fileList.append(Arguments.refFASTA)
	fileList.append(Arguments.adaptaters)
	checkFiles(fileList)


	##################### chdir output dir #####################	

	if('/' in Arguments.output):
		liste = Arguments.output.split('/')
		dirName = '/'.join(liste[0:len(liste)-1])
		os.chdir(dirName)
		Arguments.output = "".join(liste[len(liste)-1:len(liste)])

	os.system("mkdir " + Arguments.output)	
	logFile = Arguments.output + '/' + Arguments.output + ".log"	


	os.system("echo " + strftime("%Y-%m-%d %H:%M") + " >> " + logFile)
	commandLaunched(Arguments, logFile)


	##################### ckecks SE and PE reads #####################

	readsList = checkPE(Arguments.reads)

	################ Step 1 : BAMmaker and iVCFmerge_SNP

	print "Step 1/7 ---> make BAM and VCF files"
	os.system("mkdir " + Arguments.output + "/BAM")	
	os.system("mkdir " + Arguments.output + "/VCF")	
	os.system("mkdir " + Arguments.output + "/REF")
	new_Ref = Arguments.output + "/REF/reference.fasta"
	copyfile(Arguments.refFASTA, new_Ref)
	Arguments.refFASTA = os.path.abspath(new_Ref)


	#for each PE/SE reads

	i = 1
	slurm_batch_BAM = []
	slurm_batch_VCF = []	
	bamFiles = []
	vcfFiles = []
	for reads in readsList :

		if " " in reads :
			r1 = reads.split(" ")[0]
		else :
			r1 = reads 

		outputName = r1.split("/")[-1]
		print(outputName)
		outputName = outputName.split(".")[-2]	
		if("_R1" in outputName):
			outputName = outputName.replace("_R1","")
		if("_1." in outputName):
			outputName = outputName.replace("_1.",".")
		if("_R2" in outputName):
			outputName = outputName.replace("_R2","")		
		if("_2." in outputName):
			outputName = outputName.replace("_2.",".")	

		print "     - make BAM for " + outputName
		outputName_sample = outputName

		outputName = os.path.abspath(Arguments.output + "/BAM/" + outputName)
		
		cmd = ["BAMmaker" , "-ref" , Arguments.refFASTA , "-reads" , reads ,  \
			"-o" , outputName , "-q" + str(Arguments.minQuality) , \
			"-l" , str(Arguments.minLen), "-PL" , Arguments.PL , \
			"-PU" , str(Arguments.PU) , "-LB" , Arguments.LB , "-T" ,  str(Arguments.nbThreads) , \
			"-m " + str(Arguments.maxMemory), \
			"-GATKJAR "+ gatk_path \
			]


		if(Arguments.adaptaters):
			cmd.append(" -a " + Arguments.adaptaters)	
		if(Arguments.removeDuplicates):
			cmd.append(" --removeDuplicates ")
		if(Arguments.indelRealigner):
			cmd.append(" --indelRealigner ")
		if(Arguments.removeTmpFiles):
			cmd.append(" --removeTmpFiles ")	


		os.system("echo " + " ".join(cmd) + " >> " + logFile)
		if not Arguments.slurm:
                        os.system(" ".join(cmd) + " >> " + logFile + " 2>&1")
                else:
			slurm_batch_BAM.append(slurm_batch("BAM_"+str(outputName_sample)," ".join(cmd),Arguments))


		outputName_old = outputName		

		if(Arguments.removeDuplicates and Arguments.indelRealigner):
			outputName = outputName + "_removedup_realigned.bam"
		elif(Arguments.removeDuplicates):
			outputName = outputName + "_removedup.bam"
		elif(Arguments.indelRealigner):		
			outputName = outputName + "_realigned.bam"
		else:
			outputName = outputName + "_sorted.bam"	

		bamFiles.append(outputName)	


		################ Step 1.2 : iVCFmaker

		print "     - make VCF for " + outputName_sample

		#outputName_sample = Arguments.output + "/VCF/" + outputName_sample

		cmd = ["iVCFmaker", "-ref" , Arguments.refFASTA , "-b", outputName, "-o",  Arguments.output + "/VCF/" + outputName_sample, "-m " + str(Arguments.maxMemory), \
		"-T", str(Arguments.nbThreads), \
		"-GATKJAR "+ gatk_path \
		]	

		vcfFiles.append( os.path.abspath(Arguments.output + "/VCF/" + outputName_sample + ".g.vcf"))
	
		os.system("echo " + " ".join(cmd) + " >> " + logFile)
		if not Arguments.slurm:
			os.system(" ".join(cmd) + " >> " + logFile + " 2>&1")	
		else:
			slurm_batch_VCF.append(slurm_batch("VCFmaker_"+str(outputName_sample)," ".join(cmd),Arguments,dependencies=" --dependency=afterok:"+"".join(slurm_batch_BAM[-1])))

	if Arguments.onlyVCF :
		
		if Arguments.slurm:
			slurm_batch("iVARCall2_VCFonly_"+outputName,"echo 'Done waiting for slurm jobs'",Arguments, dependencies= str(" --dependency=afterok:"+":".join(map(str, slurm_batch_VCF))),threads=1,sync=1)
		# write duration in log
		t2 = datetime.datetime.now()
		duration = t2 - t1
		duration = round(duration.total_seconds()/60,0)
		os.system("echo " + "Duration : " + str(duration) + " min " + " >> " + logFile)

		os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")

		print "Finish !"		
		sys.exit(0)


	################ Step 2 : iVCFmerge 

	outputName = Arguments.output + "/VCF/" + Arguments.output

	print "Step 2/7 ---> merge all VCF files"

	cmd = ["iVCFmerge", "-ref" , Arguments.refFASTA , "-f", " ".join(vcfFiles), "-o", \
		outputName, "-m " + str(Arguments.maxMemory), \
		"-T", str(Arguments.nbThreads), \
                "-GATKJAR "+ gatk_path \
                ]

			
	os.system("echo " + " ".join(cmd) + " >> " + logFile)
	if not Arguments.slurm:
		os.system(" ".join(cmd) + " >> " + logFile + " 2>&1")	
	else:
		print(str(" --dependency=afterok:")+ ":".join(map(str, slurm_batch_VCF)) ) 
		print(str(slurm_batch_VCF))
		slurm_VCFmerge_id = slurm_batch("VCFmerge"," ".join(cmd), Arguments, dependencies=str(" --dependency=afterok:")+ ":".join(slurm_batch_VCF),mem=32000,threads=1 )

	################ Step 3 : VCFilter

	print "Step 3/7 ---> Variants filter"

	cmd = ["VCFilter", \
	"-i", outputName + "_SNP_INDEL.vcf", \
	"-o", outputName + "_SNP_INDEL_filtered"]

	#print " ".join(cmd)
	os.system("echo " + " ".join(cmd) + " >> " + logFile)
	
	if not Arguments.slurm:
		os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
	else:
		slurm_VCFilter_id = slurm_batch("VCFilter"," ".join(cmd),Arguments,dependencies=" --dependency=afterok:"+str(slurm_VCFmerge_id), threads=1)


	if(Arguments.removeTmpFiles):
		os.system("rm " + outputName + "_SNP_INDEL.vcf*")


	################ Step 4 : vcf to matrix

	print "Step 4/7 ---> make matrix from VCF"

	os.system("mkdir " + Arguments.output + "/matrix")
	outputName2 = Arguments.output + "/matrix/" + Arguments.output

	cmd = ["VCFtoMATRIX", "-i", outputName + "_SNP_INDEL_filtered.vcf", "-o", outputName2 ]	

	os.system("echo " + " ".join(cmd) + " >> " + logFile)
	
	#os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
	if not Arguments.slurm:
		os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
        else:
		slurm_VCFtoMatrix_id = slurm_batch("VCFtoMatrix"," ".join(cmd),Arguments,dependencies=" --dependency=afterok:"+str(slurm_VCFmerge_id), threads=1)



	################ Step 4 : vcf to fasta

	print "Step 5/7 ---> concatenate variant in FASTA file"

	os.system("mkdir " + Arguments.output + "/FASTA")
	outputName3 = Arguments.output + "/FASTA/" + Arguments.output

	cmd = ["VCFtoFASTA", "-i", outputName + "_SNP_INDEL_filtered.vcf", "-o", outputName3, \
	'--SNP', "--INDEL"]

	os.system("echo " + " ".join(cmd) + " >> " + logFile)
	
	if not Arguments.slurm:
                os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
        else:
                slurm_VCFtoFasta_id = slurm_batch("VCFtoFasta"," ".join(cmd),Arguments,dependencies=" --dependency=afterok:"+str(slurm_VCFmerge_id), threads=1)


	################ Step 5 : vcf to pseudo genome

	print "Step 6/7 ---> pseudo genome reconstruction"

	cmd = ["VCFtoPseudoGenome", "-i", outputName + "_SNP_INDEL_filtered.vcf -ref ",\
	Arguments.refFASTA, "-o", outputName3 + '_pseudoGenomes.fasta']

	#print " ".join(cmd)
	os.system("echo " + " ".join(cmd) + " >> " + logFile)
	
	if not Arguments.slurm:
                os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
        else:
                slurm_VCFtoPseudoGenome_id = slurm_batch("VCFtoPseudogenome"," ".join(cmd),Arguments,dependencies=" --dependency=afterok:"+str(slurm_VCFmerge_id), threads=1)



	################ Step 9 : make report

	print "Step 7/7 ---> making pdf report"

	cmd = ["iReportMaker2", "-i", logFile, "-o", Arguments.output + '/' + Arguments.output]

	os.system("echo " + " ".join(cmd) + " >> " + logFile)

	# write duration in log
	t2 = datetime.datetime.now()
	duration = t2 - t1
	duration = round(duration.total_seconds()/60,0)
	os.system("echo " + "Duration : " + str(duration) + " min " + " >> " + logFile)

	os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
	if not Arguments.slurm:
		os.system(" ".join(cmd) + ">> " + logFile + " 2>&1")
        else:
		slurm_Report_id = slurm_batch("Report"," ".join(cmd),Arguments,dependencies=" --dependency=afterok:"+str(slurm_VCFtoPseudoGenome_id)+":"+str(slurm_VCFtoFasta_id)+":"+str(slurm_VCFtoMatrix_id)+":"+str(slurm_VCFilter_id)+":"+ ":".join(map(str, slurm_batch_VCF)) +":"+  ":".join(map(str, slurm_batch_BAM)),threads=1,sync=1)
		#slurm_report_id = slurm_batch("Report_"+outputName,"echo 'Done waiting for slurm Report job'",Arguments, dependencies= " --dependency=afterok:"+str(slurm_Report_id),threads=1)
		slurm_batch("Cleanup_"+outputName,"scancel "+str(slurm_VCFtoPseudoGenome_id)+" "+str(slurm_VCFtoFasta_id)+" "+str(slurm_VCFtoMatrix_id)+" "+str(slurm_VCFilter_id) +" "+ str(slurm_VCFmerge_id)+ " " + " ".join(map(str, slurm_batch_VCF)) +  " " + " ".join(map(str, slurm_batch_BAM)),Arguments,dependencies= " --dependency=afterok:"+str(slurm_Report_id),threads=1,sync=1 )

	
	print "Finish !"
	

if __name__ == "__main__":
	main()	        	
#!/global/conda/envs/artwork/bin/python
